'''
@module Communication Structure Tree
'''

from ..base import Graph, Node
from .program_structure_graph import NodeType, ProgramStructureGraph
from typing import List, Optional, Dict, Set
from enum import Enum

'''
@enum CommType
'''


class CommType(Enum):
    """Enumeration of MPI communication types."""
    POINT_TO_POINT = "p2p"
    COLLECTIVE = "collective"
    ONE_SIDED = "one_sided"
    BROADCAST = "broadcast"
    REDUCE = "reduce"
    SCATTER = "scatter"
    GATHER = "gather"
    ALLTOALL = "alltoall"
    ALLREDUCE = "allreduce"
    BARRIER = "barrier"


'''
@class CommStructureTree
Represent the static communication structure of a program
'''


class CommStructureTree(Graph):
    """
    CommStructureTree is a pruned version of a Program Structure Graph (PSG).
    
    The CST is generated by pruning the PSG to only include nodes that have MPI 
    communication operations as descendants. The basic Call, Loop, and Branch structure 
    from PSG is preserved, but only paths leading to MPI operations are kept.
    
    Key characteristics:
    - MPI communication nodes are leaf nodes
    - Non-MPI leaf nodes are pruned
    - Internal nodes (functions, loops, branches) are kept only if they have MPI descendants
    - Preserves the hierarchical structure from PSG
    
    Attributes:
        m_mpi_nodes: Set of node IDs representing MPI communication operations
        m_comm_type_map: Dictionary mapping MPI node IDs to communication types
        m_source_psg: Reference to the source Program Structure Graph
    """
    
    def __init__(self) -> None:
        """Initialize a CommStructureTree."""
        super().__init__()
        self.m_mpi_nodes: Set[int] = set()
        self.m_comm_type_map: Dict[int, CommType] = {}
        self.m_source_psg: Optional[ProgramStructureGraph] = None
    
    def buildFromPSG(self, psg: ProgramStructureGraph, 
                     mpi_node_ids: Set[int],
                     comm_type_map: Dict[int, CommType]) -> None:
        """
        Build the Communication Structure Tree by pruning a Program Structure Graph.
        
        This method creates the CST by:
        1. Identifying all MPI communication nodes in the PSG
        2. Finding all ancestors of MPI nodes
        3. Copying nodes from PSG to CST only if they have MPI descendants
        4. Preserving the call, loop, and branch structure from PSG
        
        Args:
            psg: Source Program Structure Graph
            mpi_node_ids: Set of node IDs representing MPI operations in the PSG
            comm_type_map: Dictionary mapping MPI node IDs to their communication types
        """
        self.m_source_psg = psg
        self.m_mpi_nodes = mpi_node_ids.copy()
        self.m_comm_type_map = comm_type_map.copy()
        
        # Find all nodes that should be included (MPI nodes and their ancestors)
        nodes_to_include = self._findNodesWithMPIDescendants(psg, mpi_node_ids)
        
        # Copy nodes from PSG to CST
        for node_id in nodes_to_include:
            node = psg.getNode(node_id)
            if node is not None:
                # Create a copy of the node
                new_node = Node(node.getId(), node.getName(), node.getType())
                # Copy all attributes
                for key, value in node.m_attributes.items():
                    new_node.setAttribute(key, value)
                
                # Mark MPI nodes
                if node_id in mpi_node_ids:
                    new_node.setAttribute("is_mpi", True)
                    new_node.setAttribute("comm_type", comm_type_map.get(node_id).value if node_id in comm_type_map else "unknown")
                
                self.addNode(new_node)
        
        # Copy edges between included nodes
        for parent_id in nodes_to_include:
            if parent_id in psg.m_edges:
                for child_id in psg.m_edges[parent_id]:
                    if child_id in nodes_to_include:
                        self.addEdge(parent_id, child_id)
    
    def _findNodesWithMPIDescendants(self, psg: ProgramStructureGraph, 
                                     mpi_node_ids: Set[int]) -> Set[int]:
        """
        Find all nodes in PSG that have MPI communication nodes as descendants.
        
        Args:
            psg: Program Structure Graph to search
            mpi_node_ids: Set of MPI node IDs
            
        Returns:
            Set of node IDs that should be included in the CST
        """
        nodes_to_include = set(mpi_node_ids)
        
        # Find all ancestors of MPI nodes
        for mpi_node_id in mpi_node_ids:
            ancestors = self._findAncestors(psg, mpi_node_id)
            nodes_to_include.update(ancestors)
        
        return nodes_to_include
    
    def _findAncestors(self, psg: ProgramStructureGraph, node_id: int) -> Set[int]:
        """
        Find all ancestors of a node in the PSG.
        
        Args:
            psg: Program Structure Graph
            node_id: ID of the node to find ancestors for
            
        Returns:
            Set of ancestor node IDs
        """
        ancestors = set()
        
        # Find all nodes that have this node as a child
        for parent_id, children in psg.m_edges.items():
            if node_id in children:
                ancestors.add(parent_id)
                # Recursively find ancestors of the parent
                ancestors.update(self._findAncestors(psg, parent_id))
        
        return ancestors
    
    def addMPINode(self, node_id: int, name: str, comm_type: CommType,
                   source: Optional[int] = None,
                   dest: Optional[int] = None,
                   tag: Optional[int] = None,
                   communicator: Optional[int] = None,
                   root: Optional[int] = None) -> Node:
        """
        Add an MPI communication node to the CST.
        
        This method should be used when manually building a CST without a source PSG.
        
        Args:
            node_id: Unique identifier for the MPI node
            name: Name of the MPI operation (e.g., "MPI_Send", "MPI_Bcast")
            comm_type: Type of communication
            source: Source process rank (for point-to-point)
            dest: Destination process rank (for point-to-point)
            tag: Message tag (for point-to-point)
            communicator: Communicator ID
            root: Root process rank (for rooted collectives)
            
        Returns:
            Created MPI node
        """
        node = Node(node_id, name, "mpi_call")
        node.setAttribute("is_mpi", True)
        node.setAttribute("comm_type", comm_type.value)
        
        if source is not None:
            node.setAttribute("source", source)
        if dest is not None:
            node.setAttribute("dest", dest)
        if tag is not None:
            node.setAttribute("tag", tag)
        if communicator is not None:
            node.setAttribute("communicator", communicator)
        if root is not None:
            node.setAttribute("root", root)
        
        self.addNode(node)
        self.m_mpi_nodes.add(node_id)
        self.m_comm_type_map[node_id] = comm_type
        
        return node
    
    def getMPINodes(self) -> List[Node]:
        """
        Get all MPI communication nodes.
        
        Returns:
            List of MPI nodes
        """
        return [self.getNode(node_id) for node_id in self.m_mpi_nodes
                if self.getNode(node_id) is not None]
    
    def getMPINodesByType(self, comm_type: CommType) -> List[Node]:
        """
        Get MPI nodes of a specific communication type.
        
        Args:
            comm_type: Type of communication to filter by
            
        Returns:
            List of MPI nodes of the specified type
        """
        return [
            self.getNode(node_id) for node_id in self.m_mpi_nodes
            if self.m_comm_type_map.get(node_id) == comm_type and self.getNode(node_id) is not None
        ]
    
    def getPointToPointCount(self) -> int:
        """Get the number of point-to-point MPI communications."""
        return len(self.getMPINodesByType(CommType.POINT_TO_POINT))
    
    def getCollectiveCount(self) -> int:
        """Get the total number of collective MPI communications."""
        count = 0
        for comm_type in CommType:
            if comm_type not in [CommType.POINT_TO_POINT, CommType.ONE_SIDED]:
                count += len(self.getMPINodesByType(comm_type))
        return count
    
    def getCommunicationPattern(self) -> Dict[str, List[tuple]]:
        """
        Extract communication patterns from the CST.
        
        Returns:
            Dictionary mapping pattern types to lists of communication info tuples
        """
        patterns = {
            "p2p": [],
            "collective": []
        }
        
        for node_id in self.m_mpi_nodes:
            node = self.getNode(node_id)
            if node is None:
                continue
            
            comm_type_str = node.getAttribute("comm_type")
            if comm_type_str == CommType.POINT_TO_POINT.value:
                source = node.getAttribute("source")
                dest = node.getAttribute("dest")
                if source is not None and dest is not None:
                    patterns["p2p"].append((source, dest))
            else:
                patterns["collective"].append((node.getName(), comm_type_str))
        
        return patterns
    
    def getMaxNestingDepth(self) -> int:
        """
        Get the maximum nesting depth of the CST structure.
        
        This represents how deep the call/loop/branch structure goes from
        root to MPI leaf nodes.
        
        Returns:
            Maximum nesting depth
        """
        if not self.m_mpi_nodes:
            return 0
        
        max_depth = 0
        
        # Find root nodes (nodes with no incoming edges)
        root_nodes = []
        all_children = set()
        for children in self.m_edges.values():
            all_children.update(children)
        
        for node in self.m_nodes:
            if node.getId() not in all_children:
                root_nodes.append(node.getId())
        
        # Calculate depth from each root to MPI nodes
        for root_id in root_nodes:
            depth = self._calculateDepthFromNode(root_id, 0)
            max_depth = max(max_depth, depth)
        
        return max_depth
    
    def _calculateDepthFromNode(self, node_id: int, current_depth: int) -> int:
        """
        Calculate maximum depth from a node to MPI leaf nodes.
        
        Args:
            node_id: Current node ID
            current_depth: Current depth from root
            
        Returns:
            Maximum depth to MPI leaves
        """
        if node_id in self.m_mpi_nodes:
            return current_depth
        
        max_depth = current_depth
        if node_id in self.m_edges:
            for child_id in self.m_edges[node_id]:
                child_depth = self._calculateDepthFromNode(child_id, current_depth + 1)
                max_depth = max(max_depth, child_depth)
        
        return max_depth